Bubble Sort Algorithm
=======================

1. Algorithm Summary
----------------------

Bubble Sort is a simple comparison-based sorting algorithm that repeatedly steps through the list, compares adjacent elements, and swaps them if they are in the wrong order. The pass through the list is repeated until the list is sorted.

a) Key Features

- In-place, meaning it doesn't require extra space for sorting.
- Stable, meaning the relative order of equal elements is preserved.

b) Pseudocode

- Start from the beginning of the list.
- Compare adjacent elements and swap them if they are in the wrong order.
- Repeat this process for each pair of adjacent elements in the list until no swaps are needed.

2. Complexity Analysis
------------------------

a) Time Complexity

Best-case: **O(n)** when the list is already sorted.

Average-case and worst-case: **O(n^2)** comparisons and swaps, where n is the number of elements in the list.

b) Space Complexity

In all cases, space complexity is **O(1)** because Bubble Sort is an in-place sorting algorithm.

3. Further Considerations
---------------------------

Bubble Sort is not suitable for large datasets due to its quadratic time complexity. It is often used as a teaching tool due to its simplicity, but it's rarely used in practice for real-world applications where efficiency is critical.

4. Implementation
------------------

We implement bubble sort as a finite state machine with the following states:

#bubble-sort(arr<u8>) -> <u8> :=
    | Start(<u8>,<ix>)
    | Comparion(<u8>,<ix>) 
    | Check(<u8>,<ix>)
    | Done.

Here's the implementation of the machine:

#bubble-sort(arr<u8>) => Start(arr,0)

    -- Move to state Comparison with input list and no swaps
    Start(arr, swaps) => Comparison(arr, swaps)
    
    -- If list is empty, Move to state Check Sorted with list and swaps
    Comparison([], swaps) => Check(arr, swaps)
    
    -- If head > head of tail, swap(head, head of tail), Move to state Swapped with updated list and swaps + 1
    -- If head <= head of tail, Move to state Comparison with tail of list and current swaps
    Comparison([a, b, tail], swaps) => {
        if a > b => Comparison([b, a, tail], swaps+1)
        else => Comparison(tail, swaps)
    }
    
    -- If swaps = 0, Move to state Done with sorted list
    Check(arr, 0) => Done(arr)

    -- If swaps > 0, Move to state Start with list and 0 swaps
    Check(arr, swaps) => Start(arr,0)
    
    Done(arr) -> arr.

5. Interface
--------------

Take a list, a, that's just a list of numbers

    a = [4 2 1 3]

We can create an instance of the bubble sort FSM

    #b := #bubble-sort

The following demonstrates 5 different ways to call a state machine.

    a => #b -> a-sorted-1
    #b(a) -> a-sorted-2
    #bubble-sort(a) -> a-sorted-3
    #b([4 2 1 3]) -> a-sorted-4
    a => #bubble-sort -> a-sorted-5